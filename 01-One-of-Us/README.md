# One of Us - TDX Arena Certification Report

### Executive Summary

This project involved a cybersecurity challenge focused on identifying a malicious file and its hash signature on a compromised client system. I began by examining a directory on the Desktop filled with numerous suspicious executable files. Recognizing the limitations of the ClamAV web UI for bulk scanning, I opted for using an AI-generated Python script to automate the scanning of all files and save their results. Another script was then used to analyze these results. This process successfully identified `file176.exe` as the malicious artifact and extracted its MD5 hash signature, completing the primary objectives of the challenge.

### Findings and Analysis

| Finding | Finding Details | Description |
| :--- | :--- | :--- |
| Directory | `suspicious-files` | A directory found on the Desktop containing numerous potentially malicious `.exe` file artifacts. |
| File | `file176.exe.json` | Scan results of the infected file generated by a scan script, including the file's name, size, and hash. |
| File | `file176.exe` | The singular infected file identified in the `suspicious-files` directory. |
| Hash | MD5 - `f48a8687e91fd9ef98cd1b7aaeeb2a4c` | The MD5 hash of `file176.exe` obtained from the automated scan results. |

### Methodology

#### Tools and Technologies Used

* **ClamAV Web UI:** The primary web application for antivirus scanning.
* **Python 3:** The programming language used for scripting.
* `scan_script.py`: A custom Python script used to automate file scanning.
* `find_infected.py`: A custom Python script used to analyze scan results and identify infected files.
* `curl`: A command-line tool used for API authentication.
* `nano`: A text editor used in the terminal to create and modify Python scripts.
* **VirusTotal:** An online service for analyzing suspicious files and URLs.

#### Investigation Process

1.  **Environment Reconnaissance:** The `suspicious-files` directory was found with 272 `.exe` files, indicating potential malicious artifacts.
2.  **ClamAV UI Exploration:** Explored the ClamAV web UI, noting its lack of a built-in feature for scanning an entire directory.
3.  **Local ClamAV Attempt:** Failed to scan the `suspicious-files` directory with `clamscan` due to insufficient privileges.
4.  **ClamAV API Documentation Review:** Noted the JWT token requirement for secure authentication and file scanning.
5.  **Token Acquisition:** Successfully obtained ClamAV's authentication token using `curl`, bypassing an SSL certificate verification issue.
6.  **Python Environment Setup:** Confirmed Python 3 and `pip3` were available. Installed the `requests` library to enable HTTP requests in Python scripts.
7.  **Automated Scanning Script (`scan_script.py`):** Created and executed a Python script that parsed through all files in the `suspicious-files` directory and saved results to a new directory.
8.  **Scanning Script Verification of Results:** Verified that the `scan_results` directory was populated with individual result files, confirming successful automated scanning.
9.  **Scan Result Analysis (`find_infected.py`):** Created a second Python script to iterate through the `scan_results` directory and identify the infected file, which was successfully identified as `file176.exe`.
10. **Hash Signature Retrieval:** Examined the scan report in `file176.exe.json` to extract the malicious file's MD5 hash.
11. **VirusTotal Analysis:** Uploaded `file176.exe` to VirusTotal, which confirmed it as `trojan.shikataganai` malware.

### Figures and Screenshots

This section contains visual evidence and key screenshots from the investigation process. The images provide a step-by-step walkthrough of the methodology and serve as a visual aid to the findings.

* **Figure 1:** Malicious-Files Directory
    `![Figure 1 - Malicious-Files Directory](path/to/your-image-1.png)`

* **Figure 2:** ClamAV UI Single File Scan
    `![Figure 2 - ClamAV UI Single File Scan](path/to/your-image-2.png)`

* **Figure 3:** `clamscan` utility scan attempt
    `![Figure 3 - clamscan utility scan attempt](path/to/your-image-3.png)`

* **Figure 4:** ClamAV Application Programming Interface Documentation Review
    `![Figure 4 - ClamAV API Documentation](path/to/your-image-4.png)`

* **Figure 5:** Token Acquisition
    `![Figure 5 - Token Acquisition](path/to/your-image-5.png)`

* **Figure 6:** Python Environment Setup
    `![Figure 6 - Python Environment Setup](path/to/your-image-6.png)`

* **Figure 7:** `scan_script.py` Python Script Execution
    `![Figure 7 - scan_script.py Script Execution](path/to/your-image-7.png)`

* **Figure 8:** `scan_script.py`
    `![Figure 8 - scan_script.py](path/to/your-image-8.png)`

* **Figure 9:** `scan_results` Directory Verification
    `![Figure 9 - scan_results Directory Verification](path/to/your-image-9.png)`

* **Figure 10:** Scan Result Analysis Script Execution
    `![Figure 10 - Scan Result Analysis Script Execution](path/to/your-image-10.png)`

* **Figure 11:** `find_infected.py`
    `![Figure 11 - find_infected.py](path/to/your-image-11.png)`

* **Figure 12:** Hash Signature Retrieval
    `![Figure 12 - Hash Signature Retrieval](path/to/your-image-12.png)`

* **Figure 13:** VirusTotal Analysis of `file176.exe`
    `![Figure 13 - VirusTotal Analysis](path/to/your-image-13.png)`

* **Figure 14:** VirusTotal Details Section of `file176.exe` Analysis
    `![Figure 14 - VirusTotal Details](path/to/your-image-14.png)`

### Recommendations

1.  **Implement Robust Endpoint Security:** Deploy and maintain up-to-date antivirus and EDR solutions across all systems, configured for real-time scanning and behavioral analysis to detect and block malware.
2.  **Regular System and Network Scans:** Schedule regular, comprehensive scans of all endpoints and network segments.
3.  **Automated Threat Intelligence Integration:** Integrate security tools with threat intelligence feeds (e.g., VirusTotal) for automated file hash checking.

### Appendix: Python Scripts

Here are the full Python scripts used in this project.

#### `scan_script.py`

```python
import requests
import os
import json

base_url = "[https://clamav-ui.com](https://clamav-ui.com)"
verify_ssl = False
token = None
results_dir = "scan_results"

if not os.path.exists(results_dir): # Create the results directory if it doesn't exist
    os.makedirs(results_dir)

auth_url = f"{base_url}/api/v1/auth" # 1. Get the authentication token
try:
    response = requests.get(auth_url, verify=verify_ssl)
    response.raise_for_status()

    token_data = response.json()
    token = token_data['data']['token']
    print(f"Successfully obtained token.")
except requests.exceptions.RequestException as e:
    print(f"Error getting token: {e}")
    exit()
except (KeyError, ValueError) as e:
    print(f"Error parsing token response: {e}")
    exit()

scan_url = f"{base_url}/api/v1/scan" # 2. Scan all files in the suspicious-files directory
headers = {"Authorization": token}
files_dir = "suspicious-files"

for filename in os.listdir(files_dir):
    filepath = os.path.join(files_dir, filename)

    try:
        with open(filepath, 'rb') as f:
            files = {'file': (filename, f, 'application/octet-stream')}
            scan_response = requests.post(scan_url, headers=headers, files=files, verify=verify_ssl)
            scan_response.raise_for_status()
            scan_result = scan_response.json()
            
            # Save the result to a JSON file
            output_filepath = os.path.join(results_dir, f"{filename}.json")
            with open(output_filepath, 'w') as out_f:
                json.dump(scan_result, out_f, indent=4)
            print(f"Scan results for {filename} saved to {output_filepath}")

    except requests.exceptions.RequestException as e:
        print(f"Error scanning {filename}: {e}")
    except FileNotFoundError as e:
        print(f"File not found: {e}")
    except Exception as e:
        print(f"An unexpected error occurred for {filename}: {e}")
```

#### `find_infected.py`

```Python
import os
import json

results_dir = "scan_results"

for filename in os.listdir(results_dir):
    if filename.endswith(".json"):
        filepath = os.path.join(results_dir, filename)
        
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)

                if data.get('data') and data['data'].get('files'):
                    for file_info in data['data']['files']:
                        if file_info.get('infected'):
                            print(f"Infected file found: {file_info['fileName']}")
                            infected_filename = file_info['fileName']
                            # We can break here since we only expect one infected file
                            break
                    else: # Only executed if the inner loop did NOT break
                        continue
                    break # Break the outer loop as well
        
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Error reading or parsing {filepath}: {e}")

print("Finished checking scan results.")
```
