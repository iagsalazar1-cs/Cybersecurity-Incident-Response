## **Executive Summary**
This project involved a cybersecurity challenge focused on identifying a malicious file and its hash signature on a compromised client system. I began by examining a directory on the Desktop filled with numerous suspicious executable files. Recognizing the limitations of the ClamAV web UI for bulk scanning, I opted for using an AI-generated Python script to automate the scanning of all files and save their results. Another script was then used to analyze these results. This process successfully identified file176.exe as the malicious artifact and extracted its MD5 hash signature, completing the primary objectives of the challenge.

### **Findings and Analysis**

|Findings and Descriptions| 
|--------------------------------|
**Finding:** Directory
**Finding Details:** suspicious-files
**Description:** A directory found on the Desktop containing numerous potentially malicious .exe file artifacts.
**Finding:** File
**Finding Details:** file176.exe.json
**Description:** Scan results of the infected file generated by a scan script, including the file's name, size, and hash.
**Finding:** File
**Finding Details:** file176.exe
**Description:** The singular infected file identified in the suspicious-files directory.
**Finding:** Hash
**Finding Details:** MD5 - f48a8687e91fd9ef98cd1b7aaeeb2a4c
**Description:** The MD5 hash of file176.exe obtained from the automated scan results.

### **Methodology**

|Tools and Technologies Used|
|---------------------------|
**ClamAV Web UI:** The primary web application for antivirus scanning.
**Python 3:** The programming language used for scripting.
**scan_script.py:** A custom Python script used to automate file scanning.
**find_infected.py:** A custom Python script used to analyze scan results and identify infected files.
**curl:** A command-line tool used for API authentication.
**nano:** A text editor used in the terminal to create and modify Python scripts.
**VirusTotal:** An online service for analyzing suspicious files and URLs.

### **Investigation Process**
1.  **Environment Reconnaissance:** The suspicious-files directory was found with 272 .exe files, indicating potential malicious artifacts.
   
2.  **ClamAV UI Exploration:** Explored the ClamAV web UI, noting its lack of a built-in feature for scanning an entire directory.
  
3.  **Local ClamAV Attempt:** Failed to scan the suspicious-files directory with clamscan due to insufficient privileges.
  
4.  **ClamAV API Documentation Review:** Noted the JWT token requirement for secure authentication and file scanning.
  
5.  **Token Acquisition:** Successfully obtained ClamAV's authentication token using curl, bypassing an SSL certificate verification issue.
  
6.  **Python Environment Setup:** Confirmed Python 3 and pip3 were available. Installed the requests library to enable HTTP requests in Python scripts.
  
7.  **Automated Scanning Script (scan_script.py):** Created and executed a Python script that parsed through all files in the suspicious-files directory and saved results to a new directory.
  
8.  **Scanning Script Verification of Results:** Verified that the scan_results directory was populated with individual result files, confirming successful automated scanning.
  
9.  **Scan Result Analysis (find_infected.py):** Created a second Python script to iterate through the scan_results directory and identify the infected file, which was successfully identified as file176.exe.
  
10.  **Hash Signature Retrieval:** Examined the scan report in file176.exe.json to extract the malicious file's MD5 hash.
  
11.  **VirusTotal Analysis:** Uploaded file176.exe to VirusTotal, which confirmed it as trojan.shikataganai malware.

### **Figures and Screenshots**
This section contains visual evidence and key screenshots from the investigation process. The images provide a step-by-step walkthrough of the methodology and serve as a visual aid to the findings.

Figure 1: Screenshot of the suspicious-files directory, showing the large number of executable files.
![Directory of suspicious files](path/to/your-image-1.png)

Figure 2: Screenshot of the clamdscan error, highlighting the permission denied issue.
![Clamdscan error](path/to/your-image-2.png)

Figure 3: Screenshot of the clamav documentation, outlining the API and token requirements.
![ClamAV API documentation](path/to/your-image-3.png)

Figure 4: Screenshot of the curl command used to acquire the authentication token.
![Curl command for auth token](path/to/your-image-4.png)

Figure 5: Screenshot of the scan_script.py in the nano text editor.
![scan_script.py in nano editor](path/to/your-image-5.png)

Figure 6: Screenshot showing the execution of scan_script.py in the terminal.
![Execution of scan_script.py](path/to/your-image-6.png)

Figure 7: Screenshot of the newly created scan_results directory, confirming the script's success.
![Scan results directory](path/to/your-image-7.png)

Figure 8: Screenshot of the find_infected.py in the nano text editor.
![find_infected.py in nano editor](path/to/your-image-8.png)

Figure 9: Screenshot showing the execution of find_infected.py and the identified infected file.
![Execution of find_infected.py](path/to/your-image-9.png)

Figure 10: Screenshot of the file176.exe.json file, showing the extracted MD5 hash.
![Infected file JSON output](path/to/your-image-10.png)

Figure 11: Screenshot of the VirusTotal results for file176.exe, confirming the malware detection.
![VirusTotal scan results](path/to/your-image-11.png)

### **Recommendations**
-   **Implement Robust Endpoint Security:** Deploy and maintain up-to-date antivirus and EDR solutions across all systems, configured for real-time scanning and behavioral analysis to detect and block malware.

-   **Regular System and Network Scans:** Schedule regular, comprehensive scans of all endpoints and network segments.

-   **Automated Threat Intelligence Integration:** Integrate security tools with threat intelligence feeds (e.g., VirusTotal) for automated file hash checking.

### **Appendix: Python Scripts**
Here are the full Python scripts used in this project.

**scan_script.py**

``` python

import requests
import os
import json

base_url = "https://clamav-ui.com"
verify_ssl = False
token = None
results_dir = "scan_results"

if not os.path.exists(results_dir): # Create the results directory if it doesn't exist
    os.makedirs(results_dir)

auth_url = f"{base_url}/api/v1/auth" # 1. Get the authentication token
try:
    response = requests.get(auth_url, verify=verify_ssl)
    response.raise_for_status()

    token_data = response.json()
    token = token_data['data']['token']
    print(f"Successfully obtained token.")
except requests.exceptions.RequestException as e:
    print(f"Error getting token: {e}")
    exit()
except (KeyError, ValueError) as e:
    print(f"Error parsing token response: {e}")
    exit()

scan_url = f"{base_url}/api/v1/scan" # 2. Scan all files in the suspicious-files directory
headers = {"Authorization": token}
files_dir = "suspicious-files"

for filename in os.listdir(files_dir):
    filepath = os.path.join(files_dir, filename)

    try:
        with open(filepath, 'rb') as f:
            files = {'file': (filename, f, 'application/octet-stream')}
            scan_response = requests.post(scan_url, headers=headers, files=files, verify=verify_ssl)
            scan_response.raise_for_status()
            scan_result = scan_response.json()
            
            # Save the result to a JSON file
            output_filepath = os.path.join(results_dir, f"{filename}.json")
            with open(output_filepath, 'w') as out_f:
                json.dump(scan_result, out_f, indent=4)
            print(f"Scan results for {filename} saved to {output_filepath}")

    except requests.exceptions.RequestException as e:
        print(f"Error scanning {filename}: {e}")
    except FileNotFoundError as e:
        print(f"File not found: {e}")
    except Exception as e:
        print(f"An unexpected error occurred for {filename}: {e}")

```

**find_infected.py**

```python

import os
import json

results_dir = "scan_results"

for filename in os.listdir(results_dir):
    if filename.endswith(".json"):
        filepath = os.path.join(results_dir, filename)
        
        try:
            with open(filepath, 'r') as f:
                data = json.load(f)

                if data.get('data') and data['data'].get('files'):
                    for file_info in data['data']['files']:
                        if file_info.get('infected'):
                            print(f"Infected file found: {file_info['fileName']}")
                            infected_filename = file_info['fileName']
                            # We can break here since we only expect one infected file
                            break
                    else: # Only executed if the inner loop did NOT break
                        continue
                    break # Break the outer loop as well
        
        except (FileNotFoundError, json.JSONDecodeError) as e:
            print(f"Error reading or parsing {filepath}: {e}")

print("Finished checking scan results.")

```
